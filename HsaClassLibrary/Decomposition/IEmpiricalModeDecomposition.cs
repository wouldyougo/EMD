using System;
namespace HsaClassLibrary.Decomposition
{
    /// <summary>
    /// Empirical Mode Decomposition
    /// http://ru.wikipedia.org/wiki/Empirical_Mode_Decomposition
    /// </summary>
    interface IEmpiricalModeDecomposition
    {
        /// <summary>
        /// Empirical Mode Decomposition
        /// </summary>
        void Decomposition();
                /*
        /// Операция 0. 
        ///     Вначале R[0] = Y т.е. Разбираемый сигнал принимаем равным входному ряду
        /// Операция 1. 
        ///     Hi = Ri;
        ///     Находим в сигнале R[i] положение всех локальных экстремумов, максимумов и минимумов процесса 
        ///     (номера точек ki.ext экстремумов), и значения y(ki.ext) в этих точках. 
        ///     Между этими экстремумами сосредоточена вся информация сигнала. 
        ///     
        ///     Группируем раздельно для максимумов и для минимумов массивы координат ki.ext  и соответствующих им амплитудных значений у(ki.ext). 
        ///     Число строк в массивах максимумов и минимумов не должно отличаться более чем на 1. 
        /// Операция 2.	
        ///     Кубическим сплайном (или каким либо другим методом) вычисляем верх-нюю Ut(k) и нижнюю Ub(k) огибающие процесса соответственно, 
        ///     по максимумам и минимумам
        ///     
        /// Операция 3. 
        ///     Нахождение средней между огибающими:
        ///     Mi(k) = (Ut(k) + Ub(k))/2
        ///     
        /// Операция 4. 
        ///     Вычитание из текущего сигнала средней между огибающими:
        ///     Hi(k)  = Hi-1(k) – Mi(k)
        ///     По мере увеличения количества итераций функция Mi(k) стремится к нулевому значению, а функция Hi(k) - к неизменяемой форме. 
        ///     
        /// Операция 5. 
        ///     Проверка на продолжение итерации (проверяем продолжать ли вычитать среднюю)	
        ///     естественным критерием останова итераций является задание определенного предела по нормализованной квадратичной разности 
        ///     между двумя последовательными операциями приближения, определяемой как 
        ///     S = Sumk [|hi-1(k) - hi(k)|^2 /hi-1^2(k)]
        ///     или более эффективный критерий 
        ///     S = Sumk[|hi-1(k) - hi(k)|^2] / Sumk[hi-1^2(k)]
        ///     для выполнения качественного отсеивания модовых функций достаточно 6-8 итераций, тогда 
        ///     критерии может быть определен заданием порога S, но не более J-итераций
        ///     
        /// Операция 6. 
        ///     Сохраниене высокочастотной составляющей и удаление ее из текущего сигнала
        ///     Cn(k) = Hi(k); 
        ///     
        /// Операция 7. 
        ///     Удаление высокочастотной составляющей из текущего сигнала
        ///     Rn(k) = Rn-1(k) – Cn(k)
        ///     
        /// Операция 8. 
        ///     Проверка на завершение декомпозиции
        ///     декомпозиция сигнала в n – эмпирическом приближении:
        ///     Y(k) = Cn(k) + Rn(k)
        ///     1.	Остаток rn(k) не содержит экстремальных точек, т.е. становится либо константой, либо монотонной функцией, 
        ///         из которой больше не может быть извлечено функций IMF.
        ///     2.	Остаток rn(k) во всем интервале задания сигнала становится несущественным по своим значениям по сравнению с сигналом 
        ///         и не представляет интереса для анализа.
        ///     3.	Так как суммирование всех функций IMF (реконструкция сигнала) должно давать исходный сигнал, 
        ///         то можно останавливать разложение заданием относительной погрешности среднеквадратической реконструкции (без учета остатка rn(k)) .
        ///     4.	По мере увеличения количества функций IMF относительная среднеквадратическая погрешность реконструкции достаточно сложных 
        ///         и протяженных сигналов уменьшается, но, как правило, имеет определенный минимум. 
        ///         По-видимому, это определяется попытками алгоритма разложить остаток на функции, частично компенсирующие друг друга. 
        ///         Соответственно, останов программы может выполняться, если следующая выделенная функ-ция IMF увеличивает погрешность реконструкции.
        ///         
        /// Операция 9. 
        ///     Переход к новой итерации. n = n + 1
        */
    }
}
