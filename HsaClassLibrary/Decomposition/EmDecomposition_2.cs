//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace HsaClassLibrary.Decomposition
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text;

    /// <summary>
    /// Реализует паттерн Шаблонный метод
    /// Реализует паттерн Стратегия
    /// </summary>
    /// <remarks>
    /// Реализует паттерн Шаблонный метод: 
    /// реализует некоторые операции метода EMD
    /// Реализует паттерн Стратегия: 
    /// использует инкапсулированные Стратегии интерполяции и критерий останова для реализации некоторых операции метода EMD
    /// </remarks>
    public class EmDecomposition_2 : EmDecomposition
    {
        /// <summary>
        /// 
        /// </summary>
        /// <param name="Interpolation"></param>
        /// <param name="StopCondition"></param>
        /// <param name="StopConditionSeparate"></param>
        public EmDecomposition_2(
            Func<IList<double>, IList<double>, IList<double>, IList<double>> Interpolation, 
            IStopCondition StopCondition, 
            IStopCondition StopConditionSeparate)
            : base(Interpolation, StopCondition, StopConditionSeparate)
        {

        }
        /// <summary>
        /// 
        /// </summary>
        public EmDecomposition_2()
        {

        }

        /*
        public override IList<double> Interpolation(IList<double> x)
        {
            throw new System.NotImplementedException();
        }
        */

        /// <summary>
        /// Нахождение экстремуы входного ряда
        /// </summary>
        /// <param name="source1">Входной ряд</param>
        /// <param name="xMax">Максимумы X</param>
        /// <param name="yMax">Максимумы Y</param>
        /// <param name="xMin">Минимумы X</param>
        /// <param name="yMin">Минимумы Y</param>
        public override void FindExt(IList<double> source1, out IList<double> xMax, out IList<double> yMax, out IList<double> xMin, out IList<double> yMin)
        {
            xMax = new List<double>();
            yMax = new List<double>();
            xMin = new List<double>();
            yMin = new List<double>();

            IList<double> y = source1;

            if (y.Count > 0)
            {
                xMin.Add(0);
                yMin.Add(y[0]);
                xMax.Add(0);
                yMax.Add(y[0]);

                for (int i = 1; i < y.Count - 1; i++)
                {
                    if ((y[i] < y[i - 1]) && (y[i] <= y[i + 1]))
                    {
                        xMin.Add(i);
                        yMin.Add(y[i]);
                    }
                    else if ((y[i] > y[i - 1]) && (y[i] >= y[i + 1]))
                    {
                        xMax.Add(i);
                        yMax.Add(y[i]);
                    }
                }

                if (xMin.Count > 2)
                {
                    xMin.Add(y.Count - 1);
                    yMin.Add(
                            System.Math.Min(yMin[yMin.Count - 1],y[y.Count - 1])
                            );
                    //Если есть чем подправляем начальное значение
                    yMin[0] = System.Math.Min(yMin[1], y[0]);
                }                
                else
                {
                    //если не хватило значений то берем ту же самую точку
                    xMin.Add(y.Count - 1);
                    yMin.Add(y[y.Count - 1]);
                }

                if (xMax.Count > 2)
                {
                    xMax.Add(y.Count - 1);
                    yMax.Add(
                            System.Math.Max(yMax[yMax.Count - 1],y[y.Count - 1]) 
                            );
                    //Если есть чем подправляем начальное значение
                    yMax[0] = System.Math.Max(yMax[1], y[0]); 
                }                
                else
                {
                    //если не хватило значений то берем ту же самую точку
                    xMax.Add(y.Count - 1);
                    yMax.Add(y[y.Count - 1]);
                }
            }
        }
    }	
}

